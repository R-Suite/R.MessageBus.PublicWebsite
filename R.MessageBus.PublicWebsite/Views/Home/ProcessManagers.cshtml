@{
    ViewBag.Title = "Process Managers";
}
<div class="container-fluid">
    <div class="row row-offcanvas row-offcanvas-left">
        <div class="col-xs-6 col-sm-3 sidebar-offcanvas" id="sidebar" role="navigation">
            <div class="well sidebar-nav">
                <ul class="nav nav-list">
                    <li>
                        <a href="#processManager">Process Manager</a>
                    </li>
                    <li>
                        <a href="#processManagerInRMessageBus">Process Manager in R.MessageBus</a>
                    </li>
                    <li>
                        <a href="#handling">Handling Messages</a>
                    </li>
                    <li>
                        <a href="#telluswhatyouthink">Tell Us What You Think!</a>
                    </li>
                </ul>
            </div>
        </div>
        <div class="col-xs-12 col-sm-9">

            <h2 id="processManager">Process Manager (Long runnning processes/Workflow/Saga)</h2>
            <p style="margin-top:30px;">
                <img class="img-responsive" src="scripts/images/ProcessManager.gif" />
            </p>
            <p>
                Using a Process Manager results in a so-called hub-and-spoke pattern of message flow. An incoming message initializes the Process Manager. 
                We call this message the trigger message. Based on the rules inside the process manager it sends a message to processing steps which then 
                send reply messages back. When receiving messages the Process Manager determines the next step to be executed. As a result, 
                all traffic runs through this central hub, hence the term hub-and-spoke. The downside of this central control element is the danger of 
                turning the Process Manager into a performance bottleneck.
            </p>
            <p>
                <i>See Enterprise Integration Patterns (G. Hohpe, B. Woolf, 2009: 312-321) for more details.</i>
            </p>
            <h3 id="processManagerInRMessageBus">Process Manager in R.MessageBus</h3>
            <p>
                Implementation of Process Manager in R.MessageBus is such that it handles various types of messages, over a period of time,
                while keeping an interim state.
                R.MessageBus defines the date for interim state by implementing <i>IProcessManagerData</i> where all the public properties are persisted:
                <pre><code class="cs">public class MyProcessManagerData : IProcessManagerData
{
    public Guid CorrelationId { get; set; }
    public bool Name { get; set; }
    public string Size { get; set; }
}
</code></pre>
            </p>
            <p>
                Currently R.MessageBus offers three persistance mechanisms: MongoDB, Microsoft® SQL Server™, and In-memory. 
                The MongoDB persistance implementation offers the best performance while its schema-less nature make it a perfect fit 
                for proccess manager storage. In order to use MongoDB persister, you'll need to install R.MessageBus.Persistance.MongoDb.nupkg.
                <p>
                    <pre><code class="cs">public class Program
{
    public static void Main()
    {
        Bus.Initialize(config =>
        {
            config.SetProcessManagerFinder&lt;MongoDbProcessManagerFinder&gt;();
            config.PersistenceStoreConnectionString = "mongodb://localhost/";
        });
    }
}
</code></pre>
                </p>
            </p>

            <h3 id="handling">Handling Messages in Process Manager</h3>
            <p>
                Implementing a special interface IStartProcessManager&lt;NewOrderMessage&gt; instructs R.MessageBus to create a new instance process manager.
                Please note that you can define multiple message types to start new process manager instance.
                Like any other handler, process manager consumes messages specified by the generic type argument of IMessageHandler&lt;TMessage&gt;
                and will always lookup the correct instance of process manager based on predefined rules.
                <br />
                See below for an example on how to define rules for correlating messages into the correct process manager instance.
                <p>
                    <pre><code class="cs">public class MyProcessManager : R.MessageBus.Core.ProcessManager&lt;MyProcessManagerData&gt;,
                                IStartProcessManager&lt;StartProcessManagerMessage&gt;,
                                IStartProcessManager&lt;Process1ResponseMessage&gt;,
                                IMessageHandler&lt;Process2ResponseMessage&gt;
{
    protected override void ConfigureHowToFindProcessManager(IProcessManagerPropertyMapper mapper)
    {
        mapper.ConfigureMapping<MyProcessManagerData, Process1ResponseMessage>(m => m.Name, pm => pm.Name);
        mapper.ConfigureMapping<MyProcessManagerData, Process2ResponseMessage>(m => m.PmWidget.Size.Width, pm => pm.Widget.Size);
    }
        
    // ...handlers
}
</code></pre>
                </p>            
            </p>

            <h3 id="creating">Ending Process Manager</h3>
            <p>
                ...
            </p>

                <pre><code class="cs">public class MealProcess : ProcessManager&lt;MealData&gt;, IStartProcessManager&lt;NewOrderMessage&gt;,
                           IMessageHandler&lt;BurgerCookedMessage&gt;,
                           IMessageHandler&lt;FoodPrepped&gt;
{
    private readonly IBus _bus;
    public Meal(IBus bus)
    {
        _bus = bus;
    }

    public void Execute(NewOrderMessage message)
    {
        Data.CorrelationId = Guid.NewGuid();
        Data.Meal = message.Name;
        Data.Size = message.Size;
        var prepFoodMessage = new PrepFoodMessage(Data.CorrelationId)
        {
            BunSize = message.Size
        };

        _bus.Publish(prepFoodMessage);

        var flipBurgerMessage = new CookBurgerMessage(Data.CorrelationId)
        {
            BurgerSize = message.Size
        };

        _bus.Publish(flipBurgerMessage);
    }

    public void Execute(BurgerCookedMessage message)
    {
        Data.BurgerCooked = true;
        if (Data.FoodPrepped)
        {
            _bus.Publish(new OrderReadyMessage(message.CorrelationId)
            {
            Size = Data.Size,
            Meal = Data.Meal
            });

            Complete = true;
        }
    }

    public void Execute(FoodPrepped message)
    {
        Data.FoodPrepped = true;
        if (Data.BurgerCooked)
        {
            _bus.Publish(new OrderReadyMessage(message.CorrelationId)
            {
                Size = Data.Size,
                Meal = Data.Meal
            });
            Complete = true;
        }
    }
}

</code></pre>

          <p>
          See <a href="https://github.com/R-Suite/R.MessageBus/tree/master/samples/McDonalds">McDonalds - Process Manager</a> sample application for a complete example.
          </p>

        </div>
    </div>
    <div id="telluswhatyouthink" style="padding: 20px;">@Html.Partial("../Home/_chat")</div>
    @Html.Partial("_footer")
</div>