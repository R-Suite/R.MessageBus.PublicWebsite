<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>R.MessageBus</title>

    <!-- Bootstrap -->
    <link href="scripts/dist/rmessagebus.min.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->

  </head>

  <script>
    $(document).ready(function() {
      $('[data-toggle=offcanvas]').click(function() {
        $('.row-offcanvas').toggleClass('active');
      });
    });
  </script

  <body>
    <div class="container">

      <div class="masthead">
      <h3 class="text-muted">R.MessageBus</h3>
      <nav>
      <ul class="nav nav-justified">
      <li><a href="index.html">Home</a></li>
      <li class="active"><a href="#">All guides</a></li>
      <li><a href="https://github.com/R-Suite/R.MessageBus">Code</a></li>
      <li><a href="#">Releases</a></li>
      <li><a href="#">News</a></li>
      <li><a href="#">Get in touch</a></li>
      </ul>
      </nav>
      </div>

      <br /><br />

      <div class="row row-offcanvas row-offcanvas-left">
        
        <!-- sidebar -->
        <div class="col-xs-6 col-sm-3 sidebar-offcanvas" id="sidebar" role="navigation">
            <ul class="nav">
              <li><a href="#about">About R.MessageBus</a></li>
              <li><a href="#configuring">Configuring R.MessageBus</a></li>
              <li><a href="#sendingCommands">Sending Commands (Point-To-Point)</a></li>   
              <li><a href="#publishing">Publishing Events (Publish/Subscribe)</a></li>   
              <li><a href="#processManager">Long runnning processes (Workflow)</a></li>
              <li><a href="#">Mesages with Routing Slip</a></li>
              <li><a href="#">Mesages with Recepient List</a></li> 
              <li><a href="#">Mesage Aggregation</a></li>
              <li><a href="#">Mesage Scatter-Gather</a></li>
              <li><a href="#">Mesage Streaming</a></li>
              <li><a href="#">Retries</a></li>   
              <li><a href="#">Samples</a></li> 
            </ul>
        </div>
    
        <!-- main area -->
        <div class="col-xs-12 col-sm-9">
          <h2 id="about">About</h2>
   
          <p>R.MessageBus is a simple, easy to use asynchronous .NET messaging framework for C#. It sits on top of RabbitMQ as the transport of choice, so will need to have it installed. Currently R.MessageBus is tested on on .Net 4.5  and .Net 4.5.1. 
          </p>
          <p>While R.MessageBus includes many "traditional" features found in other messaging frameworks, it adds extended support for <strong>Enterprise Integration Patterns</strong> buit-in directly into the core of the message bus, as well as high message throughput for the most demanding applications and streaming ability for transfering large files or streaming video. 
          </p>
          <p>R.MessageBus development started in early 2014 out of a specific project's need for high-performance messaging framework.
          The intial proof-of-concept turned into a full product and we slowly phased out the third-party messaging framework that we used at that time. Internaly, R.MessageBus proved to be a great success and by the end of 2014, we decided to open-source it.
          </p>

          <!--<h3>Why async messaging?</h3>
    
          <p>Unlike in conventional programming where functions are invoked directly by name, asynchronous messaging relies on sending a message to a process where supporting infrastructure select the actual code to run. The primary benefits of this architectual style are encapsulation where clients invoke services without any knowledge of their implementation; and distribution which allows developers to build systems made up of sub-systems that run on disparate computers in different locations and at different times.</p>-->


          <br />
          <h2 id="configuring">Configuring R.MessageBus</h2>
          <h3>Simple Configuration</h3>
          <p>Calling initialize with no parameters will create an instance of the Bus with default configuration options.</p>
          
          <p>


<pre>

public class Program
{
    public static void Main()
    {
        IBus bus = Bus.Initialize();
    }
}

</pre>


          </p>

          <p>
              Default configuration creates an endpoint in our messaging system that is ready to send/publish and receive messages. 
              Of course messages can only be received if we have a code to handle those messages - <a href="#">message handlers</a>. 
          </p>

          <p>Default configuration is the following,</p>

          <ul class="task-list">
            <li>Consumer - RabbitMQ</li>
            <li>Container - StructureMap</li>
            <li>ScanForMessageHandlers - True</li>
            <li>AutoStartConsuming - True</li>
            <li>AddBusToContainer - True</li>
            <li>ProcessManagerFinder - SqlServerProcessManagerFinder</li>
            <li>
              TransportSettings
              <ul class="task-list">
                <li>Host - localhost</li>
                <li>MaxRetries - 3</li>
                <li>RetryDelay - 3000 ms</li>
                <li>AuditingEnabled - false</li>
                <li>AuditQueueName - "audit"</li>
                <li>ErrorQueueName = "errors"</li>
                <li>HeartbeatQueueName = "heartbeat"</li>
                <li>MachineName = Environment.MachineName</li>
                <li>Queue.Name = System.Diagnostics.Process.GetCurrentProcess().ProcessName;</li>
              </ul>
            </li>
          </ul>

          <h3>Custom Configuration</h3>
          <p>Initialize also takes a single lambda/action parameter for custom configuration.</p>
<pre>

public class Program
{
    public static void Main()
    {
        IBus bus = Bus.Initialize(config =>
        {
            config.ScanForMesssageHandlers = true;
            config.AutoStartConsuming = false;
            config.SetQueueName("MyQueue"));
            config.SetAuditingEnabled(true));
            config.TransportSettings.MaxRetries = 5;
            config.TransportSettings.RetryDelay = 50000;
        });
    }
}

</pre>
          <p>
              Here we initialised the bus and we are ready to start sending or publishing messages. With this example we are not quite ready to consume incoming messages just yet, but don't worry about the configuration details at this point, we'll come back to that later. This is just to  demonstrate how to specify custom configuration options.
          </p>







          <h2 id="sendingCommands">Sending Commands (Point To Point)</h2>
          <p style="margin-top:30px;">
            <img class="img-responsive" src="scripts/images/PointToPoint.gif" />
          </p>
          <p>
            A Point to Point channel ensures that only one receiver consumes any given message. The channel can have multiple receivers that can consume multiple messages concurrently (Competing Consumers), but only one of them can successfully consume a particular message. This design makes consuming and processing messages highly scalable because the work can be load balanced across multiple consumers running in multiple applications on multiple computers.
          </p>
          <p>
              <i>See Enterprise Integration Patterns (G. Hohpe, B. Woolf, 2009: 103-105, 502-507) for more details.</i>
          </p>

<p>
<h3>Command Definition</h3>
<pre>

public class PointToPointMessage : Message
{
    public PointToPointMessage(Guid correlationId) : base(correlationId){}
}

</pre>
</p>

<p>
<h3>Sending Commands</h3>
<pre>

public class Program
{
    public static void Main()
    {
        var bus = Bus.Initialize(config => 
            config.AddEndPointMapping(typeof(PointToPointMessage), "PointToPoint")
        );

        bus.Send(new PointToPointMessage(id));
    }
}

</pre>
</p>

<p>
<h3>Consuming Commands</h3>
<pre>

public class Program
{
    public static void Main()
    {
        var bus = Bus.Initialize(config => config.SetEndPoint("PointToPoint"));
    }
}

</pre>
</p>
<pre>

public class PointToPointMessageHandler : IMessageHandler&lt;PointToPointMessage&gt;
{
    public void Execute(PointToPointMessage command)
    {
        Console.WriteLine("Received message - {0}", command.CorrelationId);
    }
}

</pre>
</p>
          <p>See <a href="https://github.com/R-Suite/R.MessageBus/tree/master/samples/PointToPoint">Point To Point</a> sample application for a complete example.</p>





          <h2 id="publishing">Publishing Events (Publish/Subscribe)</h2>
          <p style="margin-top:30px;">
            <img class="img-responsive" src="scripts/images/PublishSubscribe.gif" />
          </p>
          <p>
             Publish-Subscribe channel works like this: It has one input channel that splits into multiple output channels, one for each subscriber. When an event is published into the channel, the Publish-Subscribe Channel, delivers a copy of the message to each of the output channels. Each output end of the channel has only one subscriber, which is allowed to consume a message only once. In this way, each subscriber gets the message only once, and consumed copies disapear from their channels.
          </p>
          <p>
              <i>See Enterprise Integration Patterns (G. Hohpe, B. Woolf, 2009: 106-110) for more details.</i>
          </p>

<p>
<h3>Event Definition</h3>
<pre>

public class PublishSubscribeMessage : Message
{
    public PublishSubscribeMessage(Guid correlationId) : base(correlationId){}
}

</pre>
</p>

<p>
<h3>Publishing Events</h3>
<pre>

public class Program
{
    public static void Main()
    {
        var bus = Bus.Initialize();
        bus.Publish(new PublishSubscribeMessage(id));
    }
}

</pre>
</p>

<p>
<h3>Consuming Events</h3>
<pre>

public class Program
{
    public static void Main()
    {
        var bus = Bus.Initialize();
    }
}

</pre>
</p>
<pre>

public class PublishSubscribeMessageHandler : IMessageHandler&lt;PublishSubscribeMessage&gt;
{
    public void Execute(PublishSubscribeMessage message)
    {
        Console.WriteLine("Consumer 1 Received Message - {0}", message.CorrelationId);
    }
}

</pre>
</p>

        <p>See <a href="https://github.com/R-Suite/R.MessageBus/tree/master/samples/PublishSubscribe">Publish - Subscribe</a> sample application for a complete example.</p>

    



        <h2 id="processManager">Long runnning processes (Process Manager/Workflow/Saga)</h2>
          <p style="margin-top:30px;">
            <img class="img-responsive" src="scripts/images/ProcessManager.gif" />
          </p>
          <p>
            Using a Process Manager results in a so-called hub-and-spoke pattern of message flow. An incoming message initializes the Process Manager. We call this message the trigger message. Based on the rules inside the process manager it sends a message to processing steps which then send reply messages back. When receiving messages the Process Manager determines the next step to be executed. As a result, all traffic runs through this central hub, hence the term hub-and-spoke. The downside of this central control element is the danger of turning the Process Manager into a performance bottleneck.
          </p>
          <p>
              <i>See Enterprise Integration Patterns (G. Hohpe, B. Woolf, 2009: 312-321) for more details.</i>
          </p>

<p>
<h3>Creating the Process Manager</h3>
<pre>

public class MealData : IProcessManagerData
{
    public Guid CorrelationId { get; set; }
    public bool BurgerCooked { get; set; }
    public bool FoodPrepped { get; set; }
    public string Meal { get; set; }
    public string Size { get; set; }
}

</pre>

<pre>

public class MealProcess : ProcessManager&lt;MealData&gt;, IStartProcessManager&lt;NewOrderMessage&gt;,
                                                     IMessageHandler&lt;BurgerCookedMessage&gt;,
                                                     IMessageHandler&lt;FoodPrepped&gt;
{
    private readonly IBus _bus;

    public Meal(IBus bus)
    {
        _bus = bus;
    }

    public void Execute(NewOrderMessage message)
    {
        Data.CorrelationId = Guid.NewGuid();
        Data.Meal = message.Name;
        Data.Size = message.Size;

        var prepFoodMessage = new PrepFoodMessage(Data.CorrelationId)
        {
            BunSize = message.Size
        };
        _bus.Publish(prepFoodMessage);

        var flipBurgerMessage = new CookBurgerMessage(Data.CorrelationId)
        {
            BurgerSize = message.Size
        };
        _bus.Publish(flipBurgerMessage);
    }

    public void Execute(BurgerCookedMessage message)
    {
        Data.BurgerCooked = true;
        if (Data.FoodPrepped)
        {
            _bus.Publish(new OrderReadyMessage(message.CorrelationId)
            {
                Size = Data.Size,
                Meal = Data.Meal
            });
            Complete = true;
        }
    }

    public void Execute(FoodPrepped message)
    {
        Data.FoodPrepped = true;
        if (Data.BurgerCooked)
        {
            _bus.Publish(new OrderReadyMessage(message.CorrelationId)
            {
                Size = Data.Size,
                Meal = Data.Meal
            });
            Complete = true;
        }
    }
}

</pre>
</p>
        <p>See <a href="https://github.com/R-Suite/R.MessageBus/tree/master/samples/McDonalds">McDonalds - Process Manager</a> sample application for a complete example.</p>


        </div><!-- /.col-xs-12 main -->
    </div><!--/.row-->
      <!-- Site footer -->
      <footer class="footer">
        <p>&copy; R.MessageBus 2015</p>
      </footer>

    </div>

  </body>
</html>